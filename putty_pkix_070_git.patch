diff --git a/Recipe b/Recipe
index b3739b97..36291743 100644
--- a/Recipe
+++ b/Recipe
@@ -144,7 +144,7 @@ endif
 !end
 
 !begin vc vars
-CFLAGS = $(CFLAGS) /DHAS_GSSAPI
+CFLAGS = $(CFLAGS) /DHAS_GSSAPI /DUSE_CAPI /DUSE_X509
 !end
 
 !begin clangcl vars
@@ -219,7 +219,7 @@ endif
 # _WIN32_IE is required to expose identifiers that only make sense on
 # systems with IE5+ installed, such as some arguments to SHGetFolderPath().
 # WINVER etc perform a similar function for FlashWindowEx().
-CFLAGS += -D_WIN32_IE=0x0500
+CFLAGS += -D_WIN32_IE=0x0500 -DUSE_CAPI -DUSE_X509
 CFLAGS += -DWINVER=0x0500 -D_WIN32_WINDOWS=0x0410 -D_WIN32_WINNT=0x0500
 !end
 
@@ -252,7 +252,7 @@ SSH      = ssh sshcrc sshdes sshmd5 sshrsa sshrand sshsha sshblowf
          + sshaes sshccp sshsh256 sshsh512 sshbn wildcard pinger ssharcf
          + sshgssc pgssapi sshshare sshecc aqsync
 WINSSH   = SSH winnoise wincapi winpgntc wingss winshare winnps winnpc
-         + winhsock errsock
+         + winhsock errsock wincrypto
 UXSSH    = SSH uxnoise uxagentc uxgss uxshare
 
 # SFTP implementation (pscp, psftp).
@@ -274,7 +274,7 @@ CHARSET  = sbcsdat slookup sbcs utf8 toucs fromucs xenc mimeenc macenc localenc
 
 # Standard libraries.
 LIBS     = advapi32.lib user32.lib gdi32.lib comdlg32.lib
-         + shell32.lib imm32.lib ole32.lib
+         + shell32.lib imm32.lib ole32.lib crypt32.lib
 
 # Network backend sets. This also brings in the relevant attachment
 # to proxy.c depending on whether we're crypto-avoidant or not.
@@ -306,13 +306,13 @@ psftp    : [C] psftp winsftp wincons WINSSH BE_SSH SFTP wildcard WINMISC
 
 pageant  : [G] winpgnt pageant sshrsa sshpubk sshdes sshbn sshmd5 version
 	 + tree234 misc sshaes sshsha winsecur winpgntc aqsync sshdss sshsh256
-	 + sshsh512 winutils sshecc winmisc winhelp conf pageant.res LIBS
+	 + sshsh512 winutils wincrypto sshecc winmisc winhelp conf pageant.res LIBS
 
 puttygen : [G] winpgen sshrsag sshdssg sshprime sshdes sshbn sshmd5 version
          + sshrand winnoise sshsha winstore misc winctrls sshrsa sshdss winmisc
          + sshpubk sshaes sshsh256 sshsh512 IMPORT winutils puttygen.res
          + tree234 notiming winhelp winnojmp conf LIBS wintime sshecc
-         + sshecdsag winsecur
+         + sshecdsag winsecur wincrypto
 
 pterm    : [X] GTKTERM uxmisc misc ldisc settings uxpty uxsel BE_NONE uxstore
          + uxsignal CHARSET cmdline uxpterm version time xpmpterm xpmptcfg
diff --git a/mkfiles.pl b/mkfiles.pl
index a0a78fee..c3b69579 100755
--- a/mkfiles.pl
+++ b/mkfiles.pl
@@ -1022,7 +1022,7 @@ if (defined $makefiles{'vcproj'}) {
     }
 }
 
-if (defined $makefiles{'vstudio10'} || defined $makefiles{'vstudio12'}) {
+if (defined $makefiles{'vstudio10'} || defined $makefiles{'vstudio12'} || defined $makefiles{'vstudio17'}) {
 
     ##-- Visual Studio 2010+ Solution and Projects
 
@@ -1217,7 +1217,7 @@ if (defined $makefiles{'vstudio10'} || defined $makefiles{'vstudio12'}) {
             "      <SuppressStartupBanner>true</SuppressStartupBanner>\n" .
             "      <WarningLevel>Level3</WarningLevel>\n" .
             "      <AdditionalIncludeDirectories>" . (join ";", map {"..\\..\\$dirpfx$_"} @srcdirs) . ";%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n" .
-            "      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;POSIX;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n" .
+            "      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;POSIX;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_DEPRECATE;USE_CAPI;USE_X509;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n" .
             "      <AssemblerListingLocation>.\\Release\\</AssemblerListingLocation>\n" .
             "      <PrecompiledHeaderOutputFile>.\\Release\\$windows_project.pch</PrecompiledHeaderOutputFile>\n" .
             "      <ObjectFileName>.\\Release\\</ObjectFileName>\n" .
@@ -1233,6 +1233,7 @@ if (defined $makefiles{'vstudio10'} || defined $makefiles{'vstudio12'}) {
             "    <ResourceCompile>\n" .
             "      <Culture>0x0809</Culture>\n" .
             "      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n" .
+			"      <AdditionalIncludeDirectories>" . (join ";", map {"..\\..\\$dirpfx$_"} @srcdirs) . ";%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n" .
             "    </ResourceCompile>\n" .
             "    <Bscmake>\n" .
             "      <SuppressStartupBanner>true</SuppressStartupBanner>\n" .
@@ -1256,7 +1257,7 @@ if (defined $makefiles{'vstudio10'} || defined $makefiles{'vstudio12'}) {
             "      <MinimalRebuild>true</MinimalRebuild>\n" .
             "      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n" .
             "      <AdditionalIncludeDirectories>" . (join ";", map {"..\\..\\$dirpfx$_"} @srcdirs) . ";%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n" .
-            "      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;POSIX;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n" .
+            "      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;POSIX;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_DEPRECATE;USE_CAPI;USE_X509;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n" .
             "      <AssemblerListingLocation>.\\Debug\\</AssemblerListingLocation>\n" .
             "      <PrecompiledHeaderOutputFile>.\\Debug\\$windows_project.pch</PrecompiledHeaderOutputFile>\n" .
             "      <ObjectFileName>.\\Debug\\</ObjectFileName>\n" .
@@ -1273,6 +1274,7 @@ if (defined $makefiles{'vstudio10'} || defined $makefiles{'vstudio12'}) {
             "    <ResourceCompile>\n" .
             "      <Culture>0x0809</Culture>\n" .
             "      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n" .
+			"      <AdditionalIncludeDirectories>" . (join ";", map {"..\\..\\$dirpfx$_"} @srcdirs) . ";%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n" .
             "    </ResourceCompile>\n" .
             "    <Bscmake>\n" .
             "      <SuppressStartupBanner>true</SuppressStartupBanner>\n" .
diff --git a/pageant.c b/pageant.c
index a168e522..823e8558 100644
--- a/pageant.c
+++ b/pageant.c
@@ -1293,8 +1293,27 @@ int pageant_add_keyfile(Filename *filename, const char *passphrase,
 	    keylist = pageant_get_keylist1(&keylistlen);
 	} else {
 	    unsigned char *blob2;
+#ifdef USE_CAPI
+		if (0 == strncmp("cert://", filename->path, 7)
+#ifdef USE_X509
+			|| 0 == strncmp("x509://", filename->path, 7)
+#endif /* USE_X509 */
+			) {
+			blob = ssh2_userkey_loadpub(filename, NULL, &bloblen,
+				&comment, &error);
+			if(blob) {
+				sfree(filename->path);
+				filename->path = comment;
+				comment = NULL;
+			}
+		}
+		else {
+#endif /* USE_CAPI */
 	    blob = ssh2_userkey_loadpub(filename, NULL, &bloblen,
 					NULL, &error);
+#ifdef USE_CAPI
+		}
+#endif /* USE_CAPI */
 	    if (!blob) {
                 *retstr = dupprintf("Couldn't load private key (%s)", error);
 		return PAGEANT_ACTION_FAILURE;
diff --git a/ssh.c b/ssh.c
index 3f325bec..5e1d4ce9 100644
--- a/ssh.c
+++ b/ssh.c
@@ -4485,6 +4485,23 @@ static int do_ssh1_login(Ssh ssh, const unsigned char *in, int inlen,
                     logeventf(ssh, "Key file contains public key only");
 		s->privatekey_encrypted = rsakey_encrypted(s->keyfile,
                                                            NULL);
+#ifdef USE_CAPI
+		if(s->publickey_comment && 0 == strncmp("cert://", s->publickey_comment, 7)) {
+			sfree(s->keyfile->path);
+			s->keyfile->path = strdup(s->publickey_comment);
+		}
+#endif /* USE_CAPI */
+#ifdef USE_CAPI
+#ifdef USE_X509
+		else
+#endif /* USE_X509 */
+#endif /* USE_CAPI */
+#ifdef USE_X509
+			if (s->publickey_comment && 0 == strncmp("x509://", s->publickey_comment, 7)) {
+				sfree(s->keyfile->path);
+				s->keyfile->path = strdup(s->publickey_comment);
+			}
+#endif /* USE_X509 */
 	    } else {
 		char *msgbuf;
 		logeventf(ssh, "Unable to load key (%s)", error);
@@ -10061,6 +10078,23 @@ static void do_ssh2_authconn(Ssh ssh, const unsigned char *in, int inlen,
                         logeventf(ssh, "Key file contains public key only");
 		    s->privatekey_encrypted =
 			ssh2_userkey_encrypted(s->keyfile, NULL);
+#ifdef USE_CAPI
+			if(s->publickey_comment && 0 == strncmp("cert://", s->publickey_comment, 7)) {
+				sfree(s->keyfile->path);
+				s->keyfile->path = strdup(s->publickey_comment);
+			}
+#endif /* USE_CAPI */
+#ifdef USE_CAPI
+#ifdef USE_X509
+			else
+#endif /* USE_X509 */
+#endif /* USE_CAPI */
+#ifdef USE_X509
+				if (s->publickey_comment && 0 == strncmp("x509://", s->publickey_comment, 7)) {
+					sfree(s->keyfile->path);
+					s->keyfile->path = strdup(s->publickey_comment);
+				}
+#endif /* USE_X509 */
 		} else {
 		    char *msgbuf;
 		    logeventf(ssh, "Unable to load key (%s)", 
@@ -10477,8 +10511,14 @@ static void do_ssh2_authconn(Ssh ssh, const unsigned char *in, int inlen,
 		s->agentp += 4;
 		s->pkblob = (char *)s->agentp;
 		s->agentp += s->pklen;
-		s->alglen = toint(GET_32BIT(s->pkblob));
-		s->alg = s->pkblob + 4;
+		if (s->pkblob[0] == 0x30) {
+			s->alglen = 15;
+			s->alg = "x509v3-sign-rsa";
+		}
+		else {
+			s->alglen = toint(GET_32BIT(s->pkblob));
+			s->alg = s->pkblob + 4;
+		}
 		s->commentlen = toint(GET_32BIT(s->agentp));
 		s->agentp += 4;
 		s->commentp = (char *)s->agentp;
diff --git a/ssh.h b/ssh.h
index a7902f2c..7ecdf21f 100644
--- a/ssh.h
+++ b/ssh.h
@@ -93,6 +93,10 @@ struct RSAKey {
     Bignum p;
     Bignum q;
     Bignum iqmp;
+#endif
+#ifdef USE_X509
+	int cbX509BytesEncoded;
+	char *pX509BytesEncoded;
 #endif
     char *comment;
 };
@@ -475,6 +479,9 @@ extern const struct ssh_signkey ssh_ecdsa_ed25519;
 extern const struct ssh_signkey ssh_ecdsa_nistp256;
 extern const struct ssh_signkey ssh_ecdsa_nistp384;
 extern const struct ssh_signkey ssh_ecdsa_nistp521;
+#ifdef USE_X509
+extern const struct ssh_signkey ssh_x509;
+#endif
 extern const struct ssh_mac ssh_hmac_md5;
 extern const struct ssh_mac ssh_hmac_sha1;
 extern const struct ssh_mac ssh_hmac_sha1_buggy;
diff --git a/sshpubk.c b/sshpubk.c
index 1a27c313..c7cd11b1 100644
--- a/sshpubk.c
+++ b/sshpubk.c
@@ -615,6 +615,10 @@ const struct ssh_signkey *find_pubkey_alg_len(int namelen, const char *name)
 {
     if (match_ssh_id(namelen, name, "ssh-rsa"))
 	return &ssh_rsa;
+#ifdef USE_X509
+	else if (match_ssh_id(namelen, name, "x509v3-sign-rsa"))
+		return &ssh_x509;
+#endif
     else if (match_ssh_id(namelen, name, "ssh-dss"))
 	return &ssh_dss;
     else if (match_ssh_id(namelen, name, "ecdsa-sha2-nistp256"))
@@ -649,6 +653,42 @@ struct ssh2_userkey *ssh2_load_userkey(const Filename *filename,
     int passlen = passphrase ? strlen(passphrase) : 0;
     const char *error = NULL;
 
+#ifdef USE_CAPI
+	if(0 == strncmp("cert://", filename->path, 7)) {
+		alg = find_pubkey_alg("ssh-rsa");
+		ret = snew(struct ssh2_userkey);
+		ret->alg = alg;
+		public_blob_len = strlen(filename->path);
+		public_blob = (unsigned char*)filename->path;
+		ret->data = alg->openssh_createkey(alg, &public_blob, &public_blob_len);
+		if(!ret->data) {
+			sfree(ret);
+			error = "load key from certificate failed";
+			return NULL;
+		}
+		ret->comment = dupstr((((struct RSAKey*)ret->data)->comment) ?
+			(((struct RSAKey*)ret->data)->comment) : "");
+		return ret;
+	}
+#endif /* USE_CAPI */	
+#ifdef USE_X509
+	if (0 == strncmp("x509://", filename->path, 7)) {
+		alg = find_pubkey_alg("x509v3-sign-rsa");
+		ret = snew(struct ssh2_userkey);
+		ret->alg = alg;
+		public_blob_len = strlen(filename->path);
+		public_blob = (unsigned char*)filename->path;
+		ret->data = alg->openssh_createkey(alg, &public_blob, &public_blob_len);
+		if (!ret->data) {
+			sfree(ret);
+			error = "load key from certificate failed";
+			return NULL;
+		}
+		ret->comment = dupstr((((struct RSAKey*)ret->data)->comment) ?
+			(((struct RSAKey*)ret->data)->comment) : "");
+		return ret;
+	}
+#endif /* USE_X509 */
     ret = NULL;			       /* return NULL for most errors */
     encryption = comment = mac = NULL;
     public_blob = private_blob = NULL;
@@ -1117,7 +1157,48 @@ unsigned char *ssh2_userkey_loadpub(const Filename *filename, char **algorithm,
     const char *error = NULL;
     char *comment = NULL;
 
-    public_blob = NULL;
+#ifdef USE_CAPI
+	struct RSAKey *key;
+	if(0 == strncmp("cert://", filename->path, 7)) {
+		alg = find_pubkey_alg("ssh-rsa");
+		if(algorithm) { *algorithm = dupstr(alg->name); }
+		public_blob_len = strlen(filename->path);
+		public_blob = (unsigned char*)filename->path;
+		key = (struct RSAKey*)alg->openssh_createkey(alg, &public_blob, &public_blob_len);
+		if(!key) {
+			*errorstr = "load key from certificate failed";
+			return NULL;
+		}
+		if(commentptr) { *commentptr = dupstr(key->comment); }
+		public_blob = alg->public_blob(key, pub_blob_len);
+		alg->freekey(key);
+		return public_blob;
+	}
+#endif /* USE_CAPI */
+#ifdef USE_X509
+	struct RSAKey *keyX509;
+	if (0 == strncmp("x509://", filename->path, 7)) {
+		alg = find_pubkey_alg("x509v3-sign-rsa");
+		if (algorithm) {
+			*algorithm = dupstr(alg->name);
+		}
+		public_blob_len = strlen(filename->path);
+		public_blob = (unsigned char*)filename->path;
+		keyX509 = (struct X509Key*)alg->openssh_createkey(alg, &public_blob, &public_blob_len);
+		if (!keyX509) {
+			*errorstr = "load key X509 from certificate failed";
+			return NULL;
+		}
+		if (commentptr) {
+			*commentptr = dupstr(keyX509->comment);
+		}
+		*pub_blob_len = keyX509->cbX509BytesEncoded;
+		public_blob = alg->public_blob(keyX509, pub_blob_len);
+		alg->freekey(keyX509);
+		return public_blob;
+	}
+#endif /* USE_X509 */
+	public_blob = NULL;
 
     fp = f_open(filename, "rb", FALSE);
     if (!fp) {
@@ -1642,7 +1723,7 @@ static int key_type_fp(FILE *fp)
     int i;
     char *p;
 
-    i = fread(buf, 1, sizeof(buf)-1, fp);
+	i = fread(buf, 1, sizeof(buf)-1, fp);
     rewind(fp);
 
     if (i < 0)
@@ -1680,7 +1761,17 @@ int key_type(const Filename *filename)
     FILE *fp;
     int ret;
 
-    fp = f_open(filename, "r", FALSE);
+#ifdef USE_CAPI
+	if(0 == strncmp("cert://", filename->path, 7)) {
+		return SSH_KEYTYPE_SSH2;
+	}
+#endif /* USE_CAPI */
+#ifdef USE_X509
+	if (0 == strncmp("x509://", filename->path, 7)) {
+		return SSH_KEYTYPE_SSH2;
+	}
+#endif /* USE_X509 */
+	fp = f_open(filename, "r", FALSE);
     if (!fp)
 	return SSH_KEYTYPE_UNOPENABLE;
     ret = key_type_fp(fp);
diff --git a/sshrsa.c b/sshrsa.c
index e565a64a..8d5df94b 100644
--- a/sshrsa.c
+++ b/sshrsa.c
@@ -10,6 +10,12 @@
 #include "ssh.h"
 #include "misc.h"
 
+#ifdef USE_CAPI
+#ifdef _WINDOWS
+#include "wincrypto.h"
+#endif /* _WINDOWS */
+#endif /* USE_CAPI */
+
 int makekey(const unsigned char *data, int len, struct RSAKey *result,
 	    const unsigned char **keystr, int order)
 {
@@ -411,6 +417,13 @@ int rsa_verify(struct RSAKey *key)
     Bignum n, ed, pm1, qm1;
     int cmp;
 
+#ifdef USE_CAPI
+#ifdef _WINDOWS
+	if(capi_is_capikey(key)) {
+		return 1;
+	}
+#endif /* _WINDOWS */
+#endif /* USE_CAPI */
     /* n must equal pq. */
     n = bigmul(key->p, key->q);
     cmp = bignum_cmp(n, key->modulus);
@@ -713,6 +726,13 @@ static void *rsa2_openssh_createkey(const struct ssh_signkey *self,
     const char **b = (const char **) blob;
     struct RSAKey *rsa;
 
+#ifdef USE_CAPI
+#ifdef _WINDOWS
+	if((*len >= 7) && 0 == strncmp("cert://", (const char*)*blob, 7)) {
+		return capi_load_key(blob, len);
+	}
+#endif /* _WINDOWS */
+#endif /* USE_CAPI */
     rsa = snew(struct RSAKey);
     rsa->comment = NULL;
 
@@ -872,6 +892,13 @@ static unsigned char *rsa2_sign(void *key, const char *data, int datalen,
     Bignum in, out;
     int i, j;
 
+#ifdef USE_CAPI
+#ifdef _WINDOWS
+	if(capi_is_capikey(rsa)) {
+		out = capi_rsa2_sign(rsa, data, datalen);
+	} else {
+#endif /* _WINDOWS */
+#endif /* USE_CAPI */
     SHA_Simple(data, datalen, hash);
 
     nbytes = (bignum_bitcount(rsa->modulus) - 1) / 8;
@@ -891,6 +918,11 @@ static unsigned char *rsa2_sign(void *key, const char *data, int datalen,
 
     out = rsa_privkey_op(in, rsa);
     freebn(in);
+#ifdef USE_CAPI
+#ifdef _WINDOWS
+	}
+#endif /* _WINDOWS */
+#endif /* USE_CAPI */
 
     nbytes = (bignum_bitcount(out) + 7) / 8;
     bytes = snewn(4 + 7 + 4 + nbytes, unsigned char);
@@ -1076,3 +1108,76 @@ const struct ssh_kexes ssh_rsa_kex = {
     sizeof(rsa_kex_list) / sizeof(*rsa_kex_list),
     rsa_kex_list
 };
+
+#ifdef USE_X509
+static unsigned char *x509_public_blob(void *key, int *len)
+{
+	struct RSAKey *rsa = (struct RSAKey *) key;
+	int bloblen;
+	unsigned char *blob;
+
+	bloblen = rsa->cbX509BytesEncoded;
+	blob = snewn(bloblen, unsigned char);
+	memcpy(blob, rsa->pX509BytesEncoded, bloblen);
+	*len = bloblen;
+	return blob;
+}
+
+static void *x509_openssh_createkey(const struct ssh_signkey *self,
+	const unsigned char **blob, int *len)
+{
+	const char **b = (const char **)blob;
+	struct RSAKey *rsa;
+
+	if ((*len >= 7) && 0 == strncmp("x509://", (const char*)*blob, 7)) {
+		return capi_load_key(blob, len);
+	}
+
+	return NULL;
+}
+
+
+static unsigned char *x509_sign(void *key, const char *data, int datalen,
+	int *siglen)
+{
+	struct RSAKey *rsa = (struct RSAKey *) key;
+	unsigned char *bytes;
+	int nbytes;
+	unsigned char hash[20];
+	Bignum in, out;
+	int i, j;
+
+	out = capi_rsa2_sign(rsa, data, datalen);
+
+	nbytes = (bignum_bitcount(out) + 7) / 8;
+	bytes = snewn(4 + 15 + 4 + nbytes, unsigned char);
+	PUT_32BIT(bytes, 15);
+	memcpy(bytes + 4, "x509v3-sign-rsa", 15);
+	PUT_32BIT(bytes + 4 + 15, nbytes);
+	for (i = 0; i < nbytes; i++)
+		bytes[4 + 15 + 4 + i] = bignum_byte(out, nbytes - 1 - i);
+	freebn(out);
+
+	*siglen = 4 + 15 + 4 + nbytes;
+	return bytes;
+}
+
+
+const struct ssh_signkey ssh_x509 = {
+	rsa2_newkey,
+	rsa2_freekey,
+	rsa2_fmtkey,
+	x509_public_blob,
+	rsa2_private_blob,
+	rsa2_createkey,
+	x509_openssh_createkey,
+	rsa2_openssh_fmtkey,
+	6 /* n,e,d,iqmp,q,p */,
+	rsa2_pubkey_bits,
+	rsa2_verifysig,
+	x509_sign,
+	"x509v3-sign-rsa",
+	"rsa2",
+	NULL,
+};
+#endif USE_X509
\ No newline at end of file
diff --git a/windows/wincrypto.c b/windows/wincrypto.c
new file mode 100644
index 00000000..d738b3f1
--- /dev/null
+++ b/windows/wincrypto.c
@@ -0,0 +1,417 @@
+#ifdef USE_CAPI
+/*
+ * PuTTY wincrypt patch main file.
+ * Author: Ulf Frisk, puttywincrypt@ulffrisk.com
+ */
+#include <windows.h>
+#include <wincrypt.h>
+#include "ssh.h"
+
+/*
+ * Defines and declarations due to missing declarations in mingw32 and BCC55 headers.
+ */
+#ifndef CERT_SYSTEM_STORE_CURRENT_USER
+#define CERT_SYSTEM_STORE_CURRENT_USER (1 << 16)
+#endif /* CERT_SYSTEM_STORE_CURRENT_USER */
+
+#ifndef CERT_STORE_PROV_MEMORY
+#define CERT_STORE_PROV_MEMORY ((LPCSTR) 2)
+#endif /* CERT_STORE_PROV_MEMORY */
+
+#ifndef CRYPT_FIND_USER_KEYSET_FLAG
+#define CRYPT_FIND_USER_KEYSET_FLAG 0x00000001
+#endif /* CRYPT_FIND_USER_KEYSET_FLAG */
+
+#ifndef CRYPT_FIND_SILENT_KEYSET_FLAG
+#define CRYPT_FIND_SILENT_KEYSET_FLAG 0x00000040
+#endif /* CRYPT_FIND_SILENT_KEYSET_FLAG */
+
+#ifndef CERT_CLOSE_STORE_FORCE_FLAG
+#define CERT_CLOSE_STORE_FORCE_FLAG 0x00000001
+#endif /* CERT_CLOSE_STORE_FORCE_FLAG */
+
+#ifndef CRYPT_ACQUIRE_NO_HEALING
+#define CRYPT_ACQUIRE_NO_HEALING 0x00000008
+#endif /* CRYPT_ACQUIRE_NO_HEALING */
+
+#ifndef CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG
+#define CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG 0x00010000
+#endif /* CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG */
+
+#ifndef CERT_NCRYPT_KEY_SPEC
+#define CERT_NCRYPT_KEY_SPEC 0xFFFFFFFF
+#endif /* CERT_NCRYPT_KEY_SPEC */
+
+typedef ULONG_PTR HCRYPTPROV_OR_NCRYPT_KEY_HANDLE;
+
+#ifndef __BCRYPT_H__
+#define BCRYPT_PAD_PKCS1 0x00000002
+#define BCRYPT_SHA1_ALGORITHM L"SHA1"
+typedef struct _BCRYPT_PKCS1_PADDING_INFO
+{
+	LPCWSTR pszAlgId;
+} BCRYPT_PKCS1_PADDING_INFO;
+#endif /* __BCRYPT_H__ */
+
+#ifndef CRYPT_ACQUIRE_SILENT_FLAG
+#define CRYPT_ACQUIRE_SILENT_FLAG 0x00000040
+#endif /* CRYPT_ACQUIRE_SILENT_FLAG */
+
+typedef PCCERT_CONTEXT(WINAPI *DFNCryptUIDlgSelectCertificateFromStore)(HCERTSTORE, HWND, LPCWSTR, LPCWSTR, DWORD, DWORD, PVOID);
+
+/*
+ * Dynamically lookup NCryptSignHash to avoid link dependency to ncrypt.dll (not supported by Windows XP).
+ */
+typedef LONG(WINAPI *DFNNCryptSignHash)(ULONG_PTR, PVOID, PBYTE, DWORD, PBYTE, DWORD, PDWORD, DWORD);
+
+/*
+ * convert sha1 string to binary data
+ */
+void capi_sha1_to_binary(PSTR szHex, PBYTE pbBin)
+{
+	unsigned char i, h, l;
+	for(i = 0; i < 20; i++) {
+		h = szHex[i<<1];
+		l = szHex[(i<<1) + 1];
+		pbBin[i] = 
+			(((h >= '0' && h <= '9') ? h - '0' : ((h >= 'a' && h <= 'f') ? h - 'a' + 10 : ((h >= 'A' && h <= 'F') ? h - 'A' + 10 : 0))) << 4) + 
+			(((l >= '0' && l <= '9') ? l - '0' : ((l >= 'a' && l <= 'f') ? l - 'a' + 10 : ((l >= 'A' && l <= 'F') ? l - 'A' + 10 : 0))));
+	}
+}
+
+/*
+ * Windows XP do not support CryptBinaryToString with raw hex.
+ */
+PSTR capi_binary_to_hex(PBYTE pbBinary, DWORD cbBinary)
+{
+	PSTR szHex;
+	DWORD idx;
+	BYTE b;
+	szHex = snewn((cbBinary << 1) + 1, char);
+	szHex[cbBinary << 1] = 0;
+	for(idx = 0; idx < cbBinary; idx++) {
+		b = (pbBinary[idx] >> 4) & 0x0F;
+		szHex[idx << 1] = (b < 10)?b+'0':b-10+'a';
+		b = pbBinary[idx] & 0x0F;
+		szHex[(idx << 1) + 1] = (b < 10)?b+'0':b-10+'a';
+	}
+	return szHex;
+}
+
+/*
+ * Reverse a byte array.
+ */
+void capi_reverse_array(PBYTE pb, DWORD cb)
+{
+	DWORD i;
+	BYTE t;
+	for(i = 0; i < cb >> 1; i++) {
+		t = pb[i];
+		pb[i] = pb[cb-i-1];
+		pb[cb-i-1] = t;
+	}
+}
+
+/*
+ * Select a certificate given the criteria provided.
+ * If a criterion is absent it will be disregarded.
+ */
+void capi_select_cert_2(PBYTE pbSHA1, LPWSTR wszCN, PCCERT_CONTEXT *ppCertCtx, HCERTSTORE *phStore)
+{
+	HCERTSTORE hStoreMY = NULL, hStoreTMP = NULL;
+	PCCERT_CONTEXT pCertCtx = NULL;
+	HMODULE hCryptUIDLL = NULL;
+	DFNCryptUIDlgSelectCertificateFromStore dfnCryptUIDlgSelectCertificateFromStore;
+	CRYPT_HASH_BLOB cryptHashBlob;
+	HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey;
+	DWORD dwCertCount = 0, dwKeySpec;
+	BOOL fCallerFreeProvAlwaysFalse;
+	if (!(hStoreMY = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_SYSTEM_STORE_CURRENT_USER, L"MY"))) {
+		goto error;
+	}
+	if (pbSHA1) {
+		cryptHashBlob.cbData = 20;
+		cryptHashBlob.pbData = pbSHA1;
+		if ((*ppCertCtx = CertFindCertificateInStore(hStoreMY, X509_ASN_ENCODING, 0, CERT_FIND_SHA1_HASH, &cryptHashBlob, pCertCtx))) {
+			*phStore = hStoreMY;
+			return;
+		}
+		else {
+			goto error;
+		}
+	}
+	if (!(hStoreTMP = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, 0, 0, NULL))) {
+		goto error;
+	}
+	while (TRUE) {
+		if (wszCN) {
+			pCertCtx = CertFindCertificateInStore(hStoreMY, X509_ASN_ENCODING, 0, CERT_FIND_SUBJECT_STR, wszCN, pCertCtx);
+		}
+		else {
+			pCertCtx = CertEnumCertificatesInStore(hStoreMY, pCertCtx);
+		}
+		if (!pCertCtx) {
+			break;
+		}
+		if (!CryptAcquireCertificatePrivateKey(pCertCtx, CRYPT_ACQUIRE_CACHE_FLAG | CRYPT_ACQUIRE_NO_HEALING | CRYPT_ACQUIRE_SILENT_FLAG | CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG, NULL, &hCryptProvOrNCryptKey, &dwKeySpec, &fCallerFreeProvAlwaysFalse)) {
+			continue;
+		}
+		dwCertCount++;
+		CertAddCertificateContextToStore(hStoreTMP, pCertCtx, CERT_STORE_ADD_ALWAYS, NULL);
+	}
+	CertCloseStore(hStoreMY, CERT_CLOSE_STORE_FORCE_FLAG);
+	hStoreMY = NULL;
+	if (dwCertCount == 1) {
+		*ppCertCtx = CertEnumCertificatesInStore(hStoreTMP, NULL);
+		*phStore = hStoreTMP;
+		return;
+	} else if ((dwCertCount > 1) &&
+		(hCryptUIDLL = LoadLibrary("cryptui.dll")) &&
+		(dfnCryptUIDlgSelectCertificateFromStore = (DFNCryptUIDlgSelectCertificateFromStore)GetProcAddress(hCryptUIDLL, "CryptUIDlgSelectCertificateFromStore")) &&
+		(*ppCertCtx = dfnCryptUIDlgSelectCertificateFromStore(hStoreTMP, NULL, NULL, NULL, 0, 0, NULL))) {
+		*phStore = hStoreTMP;
+		FreeLibrary(hCryptUIDLL);
+		return;
+	}
+error:
+	if (hCryptUIDLL) { FreeLibrary(hCryptUIDLL); }
+	if (hStoreTMP)	{ CertCloseStore(hStoreTMP, CERT_CLOSE_STORE_FORCE_FLAG); }
+	if (hStoreMY)	{ CertCloseStore(hStoreMY, CERT_CLOSE_STORE_FORCE_FLAG); }
+	*ppCertCtx = NULL;
+	*phStore = NULL;
+}
+
+/*
+ * Return a malloc'ed string containing the requested subitem.
+ */
+PSTR capi_select_cert_finditem(PSTR szCert, PCSTR szStart)
+{
+	PSTR ptrStart, ptrEnd, szResult;
+	ptrStart = strstr(szCert, szStart);
+	ptrEnd = strstr(szCert, ",");
+	if(!ptrEnd || ptrEnd < ptrStart) {
+		ptrEnd = szCert + strlen(szCert);
+	}
+	if(!ptrStart || ptrStart > ptrEnd) {
+		return NULL;
+	}
+	ptrStart += strlen(szStart);
+	szResult = (PSTR)calloc(ptrEnd - ptrStart + 1, sizeof(char));
+	memcpy(szResult, ptrStart, ptrEnd - ptrStart);
+	return szResult;
+}
+
+/*
+ * Select a certificate given the definition string.
+ */
+void capi_select_cert(PSTR szCert, PCCERT_CONTEXT *ppCertCtx, HCERTSTORE *phStore)
+{
+	PSTR szCN = NULL, szThumb, ptrStart, ptrStartAll;
+	LPWSTR wszCN = NULL;
+	DWORD i, len;
+	PBYTE pbThumb = snewn(20, BYTE);
+	ptrStart = strstr(szCert, "cert://");
+	ptrStartAll = strstr(szCert, "cert://*");
+#ifdef USE_X509
+	if (ptrStart == NULL && ptrStartAll == NULL) {
+		ptrStart = strstr(szCert, "x509://");
+		ptrStartAll = strstr(szCert, "x509://*");
+	}
+#endif
+	if(ptrStart != szCert) {
+		*ppCertCtx = NULL;
+		*phStore = NULL;
+		return;
+	}
+	if(ptrStartAll) {
+		capi_select_cert_2(NULL, NULL, ppCertCtx, phStore);
+		return;
+	}
+	szThumb = capi_select_cert_finditem(szCert, "thumbprint=");
+	if(szThumb && 40 == strlen(szThumb)) {
+		capi_sha1_to_binary(szThumb, pbThumb);
+		capi_select_cert_2(pbThumb, NULL, ppCertCtx, phStore);
+	} else {
+		szCN = capi_select_cert_finditem(szCert, "cn=");
+		if(szCN) {
+			len = strlen(szCN);
+			wszCN = (LPWSTR)calloc(len + 1, sizeof(wchar_t));
+			for(i = 0; i < len; i++) {
+				wszCN[i] = szCN[i];
+			}
+		}
+		capi_select_cert_2(NULL, wszCN, ppCertCtx, phStore);
+	}
+	if(szCN) { free(szCN); }
+	if(wszCN) { free(wszCN); }
+	sfree(pbThumb);
+}
+
+/* 
+ * Get rsa key comment on the form "cert://cn=<cn>,thumbprint=<sha1>".
+ */
+static PSTR capi_get_description(PSTR type, PCCERT_CONTEXT pCertContext)
+{
+	unsigned int cbCN;
+	PSTR szCN, szSHA1, szResult;
+	unsigned char hash[20];
+	cbCN = CertGetNameStringA(pCertContext, CERT_NAME_ATTR_TYPE, 0, szOID_COMMON_NAME, szCN = snewn(FILENAME_MAX, char), FILENAME_MAX);
+	SHA_Simple(pCertContext->pbCertEncoded, pCertContext->cbCertEncoded, hash);
+	szSHA1 = capi_binary_to_hex(hash, 20);
+	szResult = ((cbCN > 0) && (cbCN < FILENAME_MAX - 64)) ? 
+		dupcat(type, "://cn=", szCN, ",thumbprint=", szSHA1, NULL) :
+		dupcat(type, "://thumbprint=", szSHA1, NULL);
+	sfree(szCN);
+	sfree(szSHA1);
+	return szResult;
+}
+
+/*
+ * Load a rsa key from a certificate in windows certificate personal store.
+ */
+void *capi_load_key(unsigned char **blob, int *len) 
+{
+	BOOL result;
+	PCCERT_CONTEXT pCertContext;
+	HCERTSTORE hCertStore;
+	DWORD cbPublicKeyBlob = 8192;
+	PBYTE pbPublicKeyBlob = NULL;
+	RSAPUBKEY *pRSAPubKey;
+    struct RSAKey *rsa;
+	/* instantiate certificate and retrieve public key blob */
+	if (!((*len > 7) && (0 != strncmp("cert://", (PSTR)*blob, 7)
+#ifdef USE_X509
+		|| 0 != strncmp("x509://", (PSTR)*blob, 7)
+#endif	
+		))) {
+		return NULL;
+	}
+	capi_select_cert((PSTR)*blob, &pCertContext, &hCertStore);
+	if(!pCertContext) {
+		return NULL;
+	}
+	rsa = snew(struct RSAKey);
+#ifdef USE_X509
+	rsa->cbX509BytesEncoded = pCertContext->cbCertEncoded;
+	rsa->pX509BytesEncoded = calloc(rsa->cbX509BytesEncoded, sizeof(char)); //// TODO unalloc
+	memcpy_s(rsa->pX509BytesEncoded, rsa->cbX509BytesEncoded, pCertContext->pbCertEncoded, rsa->cbX509BytesEncoded);
+#endif
+	result = CryptDecodeObject(
+		X509_ASN_ENCODING, 
+		RSA_CSP_PUBLICKEYBLOB, 
+		pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData, 
+		pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData, 
+		0, 
+		(void*)(pbPublicKeyBlob = snewn(cbPublicKeyBlob, BYTE)),
+		&cbPublicKeyBlob);
+	if(!result) {
+		CertFreeCertificateContext(pCertContext);
+		sfree(pbPublicKeyBlob);
+		return NULL;
+	}
+	pRSAPubKey = (RSAPUBKEY*)(pbPublicKeyBlob + sizeof(BLOBHEADER));
+	/* create rsa key, set properties [no need for private_exponent,p,q,iqmp] */
+	rsa->bits = pRSAPubKey->bitlen;
+	rsa->bytes = pRSAPubKey->bitlen / 8;
+	rsa->exponent = bignum_from_long(pRSAPubKey->pubexp);
+	capi_reverse_array(pbPublicKeyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY), pRSAPubKey->bitlen / 8);
+	rsa->modulus = bignum_from_bytes((unsigned char*)pbPublicKeyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY), pRSAPubKey->bitlen / 8);
+	rsa->comment = capi_get_description("cert", pCertContext);
+#ifdef USE_X509
+	if (0 == strncmp("x509://", (PSTR)*blob, 7)) {
+		rsa->comment = capi_get_description("x509", pCertContext);
+	}
+#endif
+    rsa->private_exponent = bignum_from_long(0);
+    rsa->p = bignum_from_long(0);
+    rsa->q = bignum_from_long(0);
+    rsa->iqmp = bignum_from_long(0);
+	/* cleanup */
+	sfree(pbPublicKeyBlob);
+	CertFreeCertificateContext(pCertContext);
+	CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
+    return rsa;
+}
+
+/*
+ * Check whether the supplied key is a capi key or not.
+ */
+BOOL capi_is_capikey(struct RSAKey *rsa)
+{
+	return
+		0 == bignum_bitcount(rsa->p) &&
+		0 == bignum_bitcount(rsa->q) &&
+		0 == bignum_bitcount(rsa->iqmp) &&
+		0 == bignum_bitcount(rsa->private_exponent) &&
+		NULL != rsa->comment &&
+		(
+			NULL != strstr(rsa->comment, "cert://")
+			||
+			NULL != strstr(rsa->comment, "x509://")
+			);
+}
+
+/*
+ * Perform the signing operation.
+ */
+Bignum capi_rsa2_sign_2(struct RSAKey *rsa, char *data, int datalen, BOOL isSilent)
+{
+	Bignum ret = NULL;
+	HCERTSTORE hCertStore;
+	PCCERT_CONTEXT pCertCtx;
+	HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey = 0;
+	HCRYPTHASH hHash = 0;
+	PBYTE pbSig = NULL;
+	DWORD dwSpec, cbSig = 0;
+	BOOL fCallerFreeProvAlwaysFalse = TRUE;
+	HMODULE hNCryptDLL = NULL;
+	DFNNCryptSignHash dfnNCryptSignHash;
+	LONG win32ret;
+	BYTE bHash[20];
+	BCRYPT_PKCS1_PADDING_INFO padInfo;
+	/* perform the signing operation (terminate on any error) */
+	capi_select_cert(rsa->comment, &pCertCtx, &hCertStore);
+	if (pCertCtx && CryptAcquireCertificatePrivateKey(pCertCtx, CRYPT_ACQUIRE_CACHE_FLAG | CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG | (isSilent ? CRYPT_ACQUIRE_SILENT_FLAG : 0), 0, &hCryptProvOrNCryptKey, &dwSpec, &fCallerFreeProvAlwaysFalse)) {
+		if (dwSpec == AT_KEYEXCHANGE || dwSpec == AT_SIGNATURE) {
+			/* CSP implementation */
+			if (CryptCreateHash((HCRYPTPROV)hCryptProvOrNCryptKey, CALG_SHA1, 0, 0, &hHash) &&
+				CryptHashData(hHash, (PBYTE)data, datalen, 0) &&
+				CryptSignHash(hHash, dwSpec, NULL, 0, NULL, &cbSig) &&
+				CryptSignHash(hHash, dwSpec, NULL, 0, pbSig = snewn(cbSig, BYTE), &cbSig)) {
+				capi_reverse_array(pbSig, cbSig);
+				ret = bignum_from_bytes(pbSig, cbSig);
+			} else if (isSilent && NTE_SILENT_CONTEXT == GetLastError()) {
+				CryptSetProvParam((HCRYPTPROV)hCryptProvOrNCryptKey, PP_KEYEXCHANGE_PIN, NULL, 0);
+				CryptSetProvParam((HCRYPTPROV)hCryptProvOrNCryptKey, PP_SIGNATURE_PIN, NULL, 0);
+				ret = capi_rsa2_sign_2(rsa, data, datalen, FALSE);
+			}
+		} else if (dwSpec == CERT_NCRYPT_KEY_SPEC) {
+			/* KSP/CNG implementation */
+			SHA_Simple(data, datalen, bHash);
+			padInfo.pszAlgId = BCRYPT_SHA1_ALGORITHM;
+			if ((hNCryptDLL = LoadLibrary("ncrypt.dll")) && (dfnNCryptSignHash = (DFNNCryptSignHash)GetProcAddress(hNCryptDLL, "NCryptSignHash"))) {
+				dfnNCryptSignHash(hCryptProvOrNCryptKey, &padInfo, bHash, 20, NULL, 0, &cbSig, BCRYPT_PAD_PKCS1);
+				if (!(win32ret = dfnNCryptSignHash(hCryptProvOrNCryptKey, &padInfo, bHash, 20, pbSig = snewn(cbSig, BYTE), cbSig, &cbSig, BCRYPT_PAD_PKCS1))) {
+					ret = bignum_from_bytes(pbSig, cbSig);
+				} else if (win32ret == NTE_SILENT_CONTEXT) {
+					ret = capi_rsa2_sign_2(rsa, data, datalen, FALSE);
+				}
+			}
+		}
+	}
+	if (pbSig) { sfree(pbSig); }
+	if (hHash) { CryptDestroyHash(hHash); }
+	if (pCertCtx) { CertFreeCertificateContext(pCertCtx); }
+	if (hCertStore) { CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG); }
+	if (hNCryptDLL) { FreeLibrary(hNCryptDLL); }
+	return ret ? ret : bignum_from_long(0);
+}
+
+/*
+ * Perform the signing operation.
+ */
+Bignum capi_rsa2_sign(struct RSAKey *rsa, char *data, int datalen)
+{
+	return capi_rsa2_sign_2(rsa, data, datalen, TRUE);
+}
+#endif /* USE_CAPI */
diff --git a/windows/wincrypto.h b/windows/wincrypto.h
new file mode 100644
index 00000000..91db7aad
--- /dev/null
+++ b/windows/wincrypto.h
@@ -0,0 +1,5 @@
+#ifdef USE_CAPI
+void* capi_rsa2_sign(void *pRSAKeyStruct, char *data, int datalen);
+int capi_is_capikey(void *pRSAKeyStruct);
+void *capi_load_key(unsigned char **blob, int *len);
+#endif /* USE_CAPI */
diff --git a/windows/winpgnt.c b/windows/winpgnt.c
index 1919a9b8..fd39b7e3 100644
--- a/windows/winpgnt.c
+++ b/windows/winpgnt.c
@@ -46,6 +46,12 @@
 #define IDM_ADDKEY   0x0030
 #define IDM_HELP     0x0040
 #define IDM_ABOUT    0x0050
+#ifdef USE_CAPI
+#define IDM_ADDCERT  0x0070
+#endif /* USE_CAPI */
+#ifdef USE_X509
+#define IDM_ADDX509  0x0080
+#endif /* USE_X509 */
 
 #define APPNAME "Pageant"
 
@@ -336,9 +342,18 @@ void keylist_update(void)
              * stop and leave out a tab character. Urgh.
              */
 
-	    p = ssh2_fingerprint(skey->alg, skey->data);
-            listentry = dupprintf("%s\t%s", p, skey->comment);
-            sfree(p);
+			if (0 == strncmp("cert://", skey->comment, 7)
+#ifdef USE_X509
+				|| 0 == strncmp("x509://", skey->comment, 7)
+#endif
+				) {
+				listentry = dupprintf("%s", skey->comment);
+			}
+			else {
+				p = ssh2_fingerprint(skey->alg, skey->data);
+				listentry = dupprintf("%s\t%s", p, skey->comment);
+				sfree(p);
+			}
 
             pos = 0;
             while (1) {
@@ -347,7 +362,11 @@ void keylist_update(void)
                     break;
                 listentry[pos++] = '\t';
             }
-            if (skey->alg != &ssh_dss && skey->alg != &ssh_rsa) {
+			if (skey->alg != &ssh_dss && skey->alg != &ssh_rsa 
+#ifdef USE_X509
+				&& skey->alg != &ssh_x509
+#endif /* USE_X509 */
+				) {
                 /*
                  * Remove the bit-count field, which is between the
                  * first and second \t.
@@ -467,6 +486,100 @@ static void win_add_keyfile(Filename *filename)
     return;
 }
 
+#ifdef USE_CAPI
+/*
+ * Add a key from a Windows certificate
+ */
+static void prompt_add_capikey(void)
+{
+	int ret;
+	char *err;
+	Filename *fn = filename_from_str("cert://*");
+	ret = pageant_add_keyfile(fn, NULL, &err);
+	if (ret == PAGEANT_ACTION_OK) {
+		keylist_update();
+	} else {
+		message_box(err, APPNAME, MB_OK | MB_ICONERROR, HELPCTXID(errors_cantloadkey));
+	}
+	filename_free(fn);
+	sfree(err);
+}
+
+/*
+ * Copy key to clipboard in ssh authorized_keys format
+ */
+static void key_to_clipboard2(struct ssh2_userkey *key)
+{
+	unsigned char *pub_blob;
+	char *buffer, *p, *psz;
+	int pub_len, i;
+	HGLOBAL hClipBuffer;
+	
+	pub_blob = key->alg->public_blob(key->data, &pub_len);
+	buffer = snewn(strlen(key->alg->name) + 4 * ((pub_len + 2) / 3) + strlen(key->comment) + 3, char);
+	strcpy(buffer, key->alg->name);
+	p = buffer + strlen(buffer);
+	*p++ = ' ';
+	i = 0;
+	while(i < pub_len) {
+		int n = (pub_len - i < 3 ? pub_len - i : 3);
+		base64_encode_atom(pub_blob + i, n, p);
+		i += n;
+		p += 4;
+	}
+	*p++ = ' ';
+	strcpy(p, key->comment);
+	if(OpenClipboard(NULL)) {
+		hClipBuffer = GlobalAlloc(GMEM_MOVEABLE, strlen(buffer) + 1);
+		if(hClipBuffer) {
+			psz = (char *)GlobalLock(hClipBuffer);
+			strcpy(psz, buffer);
+			GlobalUnlock(hClipBuffer);
+			EmptyClipboard();
+			SetClipboardData(CF_TEXT, hClipBuffer);
+		}
+		CloseClipboard();
+	}
+	sfree(pub_blob);
+	sfree(buffer);
+}
+
+/*
+ * Copy 1'st selected key to clipboard in ssh authorized_keys format
+ */
+static void key_to_clipboard(HWND hwnd)
+{
+	int numSelected, *selectedArray;
+	if((numSelected = SendDlgItemMessage(hwnd, 100, LB_GETSELCOUNT, 0, 0)) > 0) {
+		selectedArray = snewn(numSelected, int);
+		SendDlgItemMessage(hwnd, 100, LB_GETSELITEMS, numSelected, (WPARAM)selectedArray);
+		key_to_clipboard2(pageant_nth_ssh2_key(selectedArray[0]));
+		sfree(selectedArray);
+	}
+}
+#endif /* USE_CAPI */
+
+#ifdef USE_X509
+/*
+* Add a key from a Windows certificate
+*/
+static void prompt_add_capikey_x509(void)
+{
+	int ret;
+	char *err;
+	Filename *fn = filename_from_str("x509://*");
+	ret = pageant_add_keyfile(fn, NULL, &err);
+	if (ret == PAGEANT_ACTION_OK) {
+		keylist_update();
+	}
+	else {
+		message_box(err, APPNAME, MB_OK | MB_ICONERROR, HELPCTXID(errors_cantloadkey));
+	}
+	filename_free(fn);
+	sfree(err);
+}
+#endif
+
 /*
  * Prompt for a key file to add, and add it.
  */
@@ -569,6 +682,13 @@ static INT_PTR CALLBACK KeyListProc(HWND hwnd, UINT msg,
 	    keylist = NULL;
 	    DestroyWindow(hwnd);
 	    return 0;
+#ifdef USE_CAPI
+	  case 100:		       /* key list */
+		if(HIWORD(wParam) == LBN_DBLCLK) {
+			key_to_clipboard(hwnd);
+		}
+		return 0;
+#endif /* USE_CAPI */
 	  case 101:		       /* add key */
 	    if (HIWORD(wParam) == BN_CLICKED ||
 		HIWORD(wParam) == BN_DOUBLECLICKED) {
@@ -891,6 +1011,16 @@ static LRESULT CALLBACK WndProc(HWND hwnd, UINT message,
 	    }
 	    prompt_add_keyfile();
 	    break;
+#ifdef USE_CAPI
+	  case IDM_ADDCERT:
+		prompt_add_capikey();
+		break;
+#endif /* USE_CAPI */
+#ifdef USE_X509
+	   case IDM_ADDX509:
+		prompt_add_capikey_x509();
+		break;
+#endif /* USE_X509 */
 	  case IDM_ABOUT:
 	    if (!aboutbox) {
 		aboutbox = CreateDialog(hinst, MAKEINTRESOURCE(213),
@@ -1271,6 +1401,12 @@ int WINAPI WinMain(HINSTANCE inst, HINSTANCE prev, LPSTR cmdline, int show)
     AppendMenu(systray_menu, MF_ENABLED, IDM_VIEWKEYS,
 	   "&View Keys");
     AppendMenu(systray_menu, MF_ENABLED, IDM_ADDKEY, "Add &Key");
+#ifdef USE_CAPI
+	AppendMenu(systray_menu, MF_ENABLED, IDM_ADDCERT, "Add &Certificate");
+#endif /* USE_CAPI */
+#ifdef USE_X509
+	AppendMenu(systray_menu, MF_ENABLED, IDM_ADDX509, "Add &X509 Certificate");
+#endif /* USE_X509 */
     AppendMenu(systray_menu, MF_SEPARATOR, 0, 0);
     if (has_help())
 	AppendMenu(systray_menu, MF_ENABLED, IDM_HELP, "&Help");
-- 
2.17.0.windows.1

